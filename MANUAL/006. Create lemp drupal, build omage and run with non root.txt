------------------------------------------------------------------------------------
Создание lemp (Drupal), сборка образов и запуск контейнеров от non root пользователя
------------------------------------------------------------------------------------

Как уже стало понятно, мы будем разворачивать LEMP инфратруктуру с CMS Drupal 9.
Данный проект отличается от того, что мы делали ранее, поэтому будем описывать сервисами.

Во всеми файлами можно ознакомится в директории с проектом - 006_lemp_drupal.
Директория - docker для построения образов.

Файл - docker-compose.yml мало изменился. Изменилось то, что мы указываем
директорию для построения собственных образов (build). Некоторые еще изменения, которых
мы коснесмя далее.

Единственное, что можно упоменуть сейчас, так это то, что мы создали сеть с определенным
cidr блоком. Так чисто для примера

networks:
  lemp:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: "172.16.254.0/24"

---------------
Контейнер mysql
---------------

Все необходимое для сборки образа для данного контейнера находится в диреткории -
docker/mysql.

Если вы посмотрите на Dockerfile, то увидите, что мы всего лишь скопировали
"свой" cnf файл. И запустили данный контейнер от пользователя - mysql.

Конечно же данный пользователь уже создан в образе - mysql:8.0. Информацию об этом
можно найти в документации - https://hub.docker.com/_/mysql

-------------------------------------------------------------------------
БОНУС:

Если мы хотим импортировать некоторый dump базы данных при старте контейнера,
то мы должны использовать вот такую срочку (она закомментирована)

COPY ./drupaldb.sql /docker-entrypoint-initdb.d/

drupaldb.sql - это dump простенькой базы данных (для примера)

docker-entrypoint-initdb.d - директория контейнера в которую помещают dump базы данных
и при старте контейнера все что находится в данной директории импортируется.

Тут есть момент.

Если вы делали dump вот таким образом (с созданием базы данных):

mysqldump --opt -v --databases <database> -u<mysql user> -p<mysql user password> > <dump name>.sql

то после старта контейнера у вас будет база данных, которая была в dump'е. Все логично и понятно.

Если вы делали dump вот таким образом (без создания базы данных):

mysqldump --opt -v --routines --triggers <database>  -u<mysql user> -p<mysql user password> > <dump name>.sql

то при старте контейнера данный dump будет импортирован в базу данных которая создана
с помощью переменной окружения - MYSQL_DATABASE.



В нашем случае - drupaldb.sql был сделан "вторым" способом т.е. без содания базы данных.
У нас есть файл в корне проекта - mysql.env.

Нас интересует вот эта часть:

MYSQL_DATABASE=drupaldb
MYSQL_USER=drupaluser
MYSQL_PASSWORD=User@12345

Таким образом при старте контейнера у нас создается база данных - drupaldb, так же создается
пользователь - drupaluser с паролем - User@12345. Данному пользователю даются полные права
на базу данных - drupaldb. Ну, а т.к. мы поместили dump в директорию - docker-entrypoint-initdb.d,
то он импортируется в данную базу данных.



---------------
Контейнер nginx
---------------

Все необходимое для сборки образа для данного контейнера находится в диреткории -
docker/nginx.

Тут мы использовали образ на основе alpine. Скопировали все необходимые nginx конфиги.
Сгенерировали самоподписанный сертификат для тестирования https. Запустили контейнер
от пользователя - nginx.

С пользователем nginx по-сложней чем в mysql контейнере. В оффициальной документации
можно найти информацию, что нужно несколько преобразовать nginx конфиги для того,
чтобы контенер запустился.

https://hub.docker.com/_/nginx

Вот что имено нужно было изменить в конфигурации

# This has looks like when only master process is NON root
pid        /tmp/nginx.pid;

http {

    ...
    # This need only when master process is NON root
    client_body_temp_path /tmp/client_temp;
    proxy_temp_path       /tmp/proxy_temp_path;
    fastcgi_temp_path     /tmp/fastcgi_temp;
    uwsgi_temp_path       /tmp/uwsgi_temp;
    scgi_temp_path        /tmp/scgi_temp;

}

Так же, вы могли заметить, что кроме nginx конфигруации для сайта (default.conf),
появился конфиг - phpmyadmin.conf. Это из-за того, что мы в прошлый раз использовали phpmyadmin
образ с установленным apache с php-fpm и он проксировал php страницы на локально установленный
в контейнере php-fpm.

Сейчас же мы будем использовать образ только с php-fpm. Это значит, что проксировать php страницы
в phpmyadmin контейнер нужно с помощью данного nginx контейнера.


Обратите внимание, что и в php-fpm контейнере, и в phpmyadmin данные расспологаются
в /var/www/html

phpfpm:
  ...
  volumes:
    - drupaldata:/var/www/html

phpmyadmin:
  ...
  volumes:
    - phpmyadmindata:/var/www/html

nginx:
  ...
  volumes:
    - drupaldata:/var/www/html
    - phpmyadmindata:/var/www/phpmyadmin


т.к. в phpmyadmin данные монтируются по одному пути, а в nginx в другом пути, то мы в конфигруации
phpmyadmin.conf для php-fpm настройки используем параметр - root, чтобы php-fpm который находится в
phpmyadmin контейнере, использовал правильный путь к данным.

Вот в чем разница

это для phpfpm контейнера:

location ~ '\.php$|^/update.php' {
    ...
    fastcgi_pass phpfpm:9000;
    ...
}

это для phpmyadmin контейнера:

location ~* \.php$ {
    ...
    fastcgi_pass   phpmyadmin:9000;
    root           /var/www/html;
    ...
}


---------------------------
Контейнер phpfpm (Drupal 9)
---------------------------

https://hub.docker.com/_/php

https://hub.docker.com/_/drupal

Все необходимое для сборки образа для данного контейнера находится в диреткории -
docker/phpfpm.

Тут мы будем использовать образ на alpine linux php-fpm на котором находится Drupal 9.

Собирая образ мы настраиваем php.ini файл так как нам нужно.

Что мы сделали? В контейнере находится папка /usr/local/etc/php/ ($PHP_INI_DIR) в которой находятся
примеры php.ini файлы (php.ini-production и php.ini-development). Мы создали
php.ini файл из php.ini-production и с помощью sed изменили некоторые настройки.

Мы бы могли сделать проще и вместо sed использовать готовый файлы на хостовой системе
и скопировать их при сборке в директорию $PHP_INI_DIR/conf.d


Так же, чисто для примера, установили некоторые php extantions'ы (docker-php-ext-install).
Дело в том, что разработчики образов сделали скрипт docker-php-ext-install с помощью которого
легко устанавливать extantions'ы.

Правда дополнительно пришлось установить библиотеки для extantions'ов. Они устанавливаются стандартно
с помощью менеджера пакетов системы. Т.к. мы использовали alpine linux, в качестве
менеджера пакетов используется (apk).

Ну, и запустили данный контейнер от пользователя ww-data.

-------------------------------------------------------
БОНУС:

В Dockerfile'е есть закомментированные строки начинающиеся с

#
# Custome Site
#

Это пример того, как можно скопировать готовый архив с сайтом. Тут главное не забыть
изменить владельца вот этим директориям - modules, sites, themes. Особенно это касается
тогда, когда данный контейнер будет запущен от non root пользователя.

-----------------------------------------------------


--------------------
Контейнер phpmyadmin
--------------------

Все необходимое для сборки образа для данного контейнера находится в диреткории -
docker/phpmyadmin.

Тут все просто.

Единственное что можно добавить, так это то, что в docker-compose.yml файле для данного
контейнера мы установили переменную UPLOAD_LIMIT. Данная переменная дает возможность
импортровать баду данных с таким максимальным размером.

Данная переменная изменяет настройки самого phpmyadmin'а, а так же настройки php.ini.
Поэтому указав данную переменную париться с настройками php не нужно.

Единственное нужно не забыть правильно снастроить web сервер. В нашем случае сделать настройку
nginx (файл limmits.conf) - client_max_body_size.









--------------------------------------
